buildscript {
    repositories {
       jcenter()
    }

    dependencies {
        classpath "org.walkmod:gradle-walkmod-plugin:0.0.1"
        classpath "de.dynamicfiles.projects.gradle.plugins:javafx-gradle-plugin:8.8.2"
        classpath "org.junit.platform:junit-platform-gradle-plugin:1.0.0-M5"
    }
}

plugins {
  id "com.gradle.build-scan" version "1.8" //should be first loaded plugin so it can scan more
  id "java"
  id "eclipse"
  id "com.diffplug.gradle.spotless" version "3.4.0"
  id "me.champeau.gradle.jmh" version "0.4.4"
  id "io.morethan.jmhreport" version "0.4.1"
  id "net.ltgt.errorprone" version "0.0.10"
  id "net.ltgt.apt" version "0.10"
}

buildScan {
  licenseAgreementUrl = "https://gradle.com/terms-of-service"
  licenseAgree = "yes"
  publishAlways()
}

description = "This is an image editor."

apply plugin: "org.junit.platform.gradle.plugin"
apply plugin: 'javafx-gradle-plugin'
apply plugin: "walkmod"

repositories {
    jcenter()
}

dependencies {
    compile "org.reactfx:reactfx:2.0-M5"
    compile "com.google.guava:guava:22.0"

    def auto_version = "1.4.1"
    def dagger_version = "2.11"

    compileOnly "org.eclipse.jdt:org.eclipse.jdt.annotation:2.1.0"

    compileOnly "org.immutables:value:2.5.5"
    apt "org.immutables:value:2.5.5"

    compile "com.google.dagger:dagger:$dagger_version"
    apt "com.google.dagger:dagger-compiler:$dagger_version"


    testCompile("org.junit.jupiter:junit-jupiter-api:5.0.0-M5")

    testRuntime("org.junit.jupiter:junit-jupiter-engine:5.0.0-M5")
}

compileJava {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
}

compileTestJava {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
    options.compilerArgs += "-parameters"
}

task wrapper(type: Wrapper){
    gradleVersion = "4.0"
}

//when and if i get more confidence in walkmod, i will activate walkmodPatch here
check.dependsOn walkmodCheck


jmh {
   ext.resultsPath = "${project.buildDir}/reports/jmh"
   iterations = 10 // Number of measurement iterations to do.
   benchmarkMode = ["thrpt","ss"] // Benchmark mode. Available modes are: [Throughput/thrpt, AverageTime/avgt, SampleTime/sample, SingleShotTime/ss, All/all]
   batchSize = 10 // Batch size: number of benchmark method calls per operation. (some benchmark modes can ignore this setting)
   fork = 4 // How many times to forks a single benchmark. Use 0 to disable forking altogether
   failOnError = true // Should JMH fail immediately if any benchmark had experienced the unrecoverable error?
   humanOutputFile = project.file("${resultsPath}/human.json") // human-readable output file
   resultsFile = project.file("${resultsPath}/results-${java.time.Instant.now()}.json") // results file
   operationsPerInvocation = 10 // Operations per invocation.
   profilers = ["gc"] // Use profilers to collect additional data. Supported profilers: [cl, comp, gc, stack, perf, perfnorm, perfasm, xperf, xperfasm, hs_cl, hs_comp, hs_gc, hs_rt, hs_thr]
   timeOnIteration = "1s" // Time to spend at each measurement iteration.
   resultFormat = "JSON" // Result format type (one of CSV, JSON, NONE, SCSV, TEXT)
   threads = 8 // Number of worker threads to run with.
   timeout = "1s" // Timeout for benchmark iteration.
   timeUnit = "ms" // Output time unit. Available time units are: [m, s, ms, us, ns].
   verbosity = "NORMAL" // Verbosity mode. Available modes are: [SILENT, NORMAL, EXTRA]
   warmup = "1s" // Time to spend at each warmup iteration.
   warmupBatchSize = 10 // Warmup batch size: number of benchmark method calls per operation.
   warmupIterations = 5 // Number of warmup iterations to do.

   jmhVersion = "1.19" // Specifies JMH version
   duplicateClassesStrategy = "fail" // Strategy to apply when encountring duplicate classes during creation of the fat jar (i.e. while executing jmhJar task)
}

jmhReport {
    jmhResultPath = project.file( jmh.resultsFile )
    jmhReportOutput = project.file( jmh.resultsPath )
}
tasks.jmh.finalizedBy tasks.jmhReport

spotless {
    java {
        licenseHeaderFile rootProject.file("config/license.header.md")
        importOrder(["java", "javax", "com", "org", "net", "net.bugabinga"])
        eclipse().configFile  rootProject.file("config/eclipse-java-google-style.xml")
        trimTrailingWhitespace()
        indentWithSpaces()
        endWithNewline()
        removeUnusedImports()
    }

    format "misc", {
        target "**/*.gradle", "**/*.md", "**/*.gitignore", "**/*.properties"
        indentWithSpaces(2)
        trimTrailingWhitespace()
        endWithNewline()
    }
}

//We want the gradle build config to be the single source of truth.
//Never depend on configurations done in an IDE.
tasks.eclipse.dependsOn(cleanEclipse)

import org.gradle.plugins.ide.eclipse.model.AccessRule
eclipse {
    project {
        comment 'An image editor.'
  // the buildship plugin in eclipse is very aggresive about rewriting the .classpath and .project files.
  // we are better of not using the plugin for now
        natures.remove('org.eclipse.buildship.core.gradleprojectnature')
        buildCommands.remove('org.eclipse.buildship.core.gradleprojectbuilder')
    }
    classpath {
        //file {
            //withXml {
                //def jreContainer = it.asNode().find {
                    //def kind = it.attribute("kind")
                   // def path = it.attribute("path")
                  //  kind == "con" &&
                 //   path != null &&
                //    path.contains("org.eclipse.jdt.launching.JRE_CONTAINER")
               // }
              //  def attributes = jreContainer.find { it.name() == "attributes" }
             //   attributes = (attributes == null) ? jreContainer.appendNode("attributes") : attributes
            //    attributes.appendNode("attribute",[name: 'annotationpath', value: 'src/external/annotations'])


                //We need to tell eclipse about the external annotations location
              //This is the goal:
              //<attributes>
              //    <attribute name="annotationpath" value="src/external/annotations"/>
              //</attributes>
           // }
        //}


	file.whenMerged {
        	entries.each { source -> 
                def jre = entries.find { it.path.contains 'org.eclipse.jdt.launching.JRE_CONTAINER' }

		//Example of what we try to achieve here
		//<accessrules>
		//	<accessrule kind="accessible" pattern="javafx/**"/>
		//</accessrules>
		
		// '0' = accessible
		// '1' = nonaccessible
		// '2' = discouraged

                jre.accessRules.add(new AccessRule("nonaccessible", 'sun/**'))
               	jre.accessRules.add(new AccessRule("nonaccessible", 'javax/swing/**'))
               	jre.accessRules.add(new AccessRule("nonaccessible", 'com/sun/**'))
               	jre.accessRules.add(new AccessRule("accessible", 'javafx/**'))

                //We need to tell eclipse about the external annotations location
                //<attributes>
                //    <attribute name="annotationpath" value="src/external/annotations"/>
                //</attributes>
 
		jre.entryAttributes.put("annotationpath","src/external/annotations")
        }
     }
	defaultOutputDir = file('build/eclipse-bin')

        downloadSources = true
        downloadJavadoc = false
    }
}
